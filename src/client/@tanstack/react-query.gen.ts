// This file is auto-generated by @hey-api/openapi-ts

import { type DefaultError, type InfiniteData, infiniteQueryOptions, queryOptions, type UseMutationOptions } from '@tanstack/react-query';

import { client } from '../client.gen';
import { authSignInCreate, instrumentsDetailRetrieve, instrumentsList, instrumentsWithPricesList, investorsList, investorsMeAccountValueList, investorsMeAssetAllocationRetrieve, investorsMeCurrentAccountValueRetrieve, investorsMeOwnedSharesRetrieve, investorsMeRetrieve, investorsMeStatisticsMostTradedList, investorsMeStatisticsProfileOverviewRetrieve, investorsMeStatisticsTradingOverviewRetrieve, investorsMeStatsRetrieve, investorsMeTransactionsHistoryList, investorsPartialUpdate, investorsRetrieve, investorsUpdate, marketsHolidaysList, marketsStatusRetrieve, newsList, type Options, ordersCancelDestroy, ordersList, ordersMarketCreate, pricesBars, pricesList, pricesRetrieve, statusRetrieve, testAdminTestRetrieve, testAllTestRetrieve, testAlpacaTestRetrieve, testPolygonTestRetrieve, testUsersTestRetrieve } from '../sdk.gen';
import type { AuthSignInCreateData, InstrumentsDetailRetrieveData, InstrumentsListData, InstrumentsListResponse, InstrumentsWithPricesListData, InstrumentsWithPricesListResponse, InvestorsListData, InvestorsListResponse, InvestorsMeAccountValueListData, InvestorsMeAssetAllocationRetrieveData, InvestorsMeCurrentAccountValueRetrieveData, InvestorsMeOwnedSharesRetrieveData, InvestorsMeRetrieveData, InvestorsMeStatisticsMostTradedListData, InvestorsMeStatisticsMostTradedListResponse, InvestorsMeStatisticsProfileOverviewRetrieveData, InvestorsMeStatisticsTradingOverviewRetrieveData, InvestorsMeStatsRetrieveData, InvestorsMeTransactionsHistoryListData, InvestorsPartialUpdateData, InvestorsPartialUpdateResponse, InvestorsRetrieveData, InvestorsUpdateData, InvestorsUpdateResponse, MarketsHolidaysListData, MarketsStatusRetrieveData, NewsListData, OrdersCancelDestroyData, OrdersCancelDestroyResponse, OrdersListData, OrdersListResponse, OrdersMarketCreateData, OrdersMarketCreateResponse, PricesBarsData, PricesListData, PricesRetrieveData, StatusRetrieveData, TestAdminTestRetrieveData, TestAllTestRetrieveData, TestAlpacaTestRetrieveData, TestPolygonTestRetrieveData, TestUsersTestRetrieveData } from '../types.gen';

/**
 * Sign in a user with email and password via Clerk
 * Authenticates a user using their email and password through Clerk, returning a sign-in token upon success.
 */
export const authSignInCreateMutation = (options?: Partial<Options<AuthSignInCreateData>>): UseMutationOptions<unknown, DefaultError, Options<AuthSignInCreateData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<AuthSignInCreateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await authSignInCreate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export type QueryKey<TOptions extends Options> = [
    Pick<TOptions, 'baseUrl' | 'body' | 'headers' | 'path' | 'query'> & {
        _id: string;
        _infinite?: boolean;
        tags?: ReadonlyArray<string>;
    }
];

const createQueryKey = <TOptions extends Options>(id: string, options?: TOptions, infinite?: boolean, tags?: ReadonlyArray<string>): [
    QueryKey<TOptions>[0]
] => {
    const params: QueryKey<TOptions>[0] = { _id: id, baseUrl: options?.baseUrl || (options?.client ?? client).getConfig().baseUrl } as QueryKey<TOptions>[0];
    if (infinite) {
        params._infinite = infinite;
    }
    if (tags) {
        params.tags = tags;
    }
    if (options?.body) {
        params.body = options.body;
    }
    if (options?.headers) {
        params.headers = options.headers;
    }
    if (options?.path) {
        params.path = options.path;
    }
    if (options?.query) {
        params.query = options.query;
    }
    return [
        params
    ];
};

export const instrumentsListQueryKey = (options?: Options<InstrumentsListData>) => createQueryKey('instrumentsList', options);

export const instrumentsListOptions = (options?: Options<InstrumentsListData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await instrumentsList({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: instrumentsListQueryKey(options)
    });
};

const createInfiniteParams = <K extends Pick<QueryKey<Options>[0], 'body' | 'headers' | 'path' | 'query'>>(queryKey: QueryKey<Options>, page: K) => {
    const params = {
        ...queryKey[0]
    };
    if (page.body) {
        params.body = {
            ...queryKey[0].body as any,
            ...page.body as any
        };
    }
    if (page.headers) {
        params.headers = {
            ...queryKey[0].headers,
            ...page.headers
        };
    }
    if (page.path) {
        params.path = {
            ...queryKey[0].path as any,
            ...page.path as any
        };
    }
    if (page.query) {
        params.query = {
            ...queryKey[0].query as any,
            ...page.query as any
        };
    }
    return params as unknown as typeof page;
};

export const instrumentsListInfiniteQueryKey = (options?: Options<InstrumentsListData>): QueryKey<Options<InstrumentsListData>> => createQueryKey('instrumentsList', options, true);

export const instrumentsListInfiniteOptions = (options?: Options<InstrumentsListData>) => {
    return infiniteQueryOptions<InstrumentsListResponse, DefaultError, InfiniteData<InstrumentsListResponse>, QueryKey<Options<InstrumentsListData>>, number | Pick<QueryKey<Options<InstrumentsListData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<InstrumentsListData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await instrumentsList({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: instrumentsListInfiniteQueryKey(options)
    });
};

export const instrumentsDetailRetrieveQueryKey = (options?: Options<InstrumentsDetailRetrieveData>) => createQueryKey('instrumentsDetailRetrieve', options);

/**
 * Retrieve an instrument by one of the following query parameters: id, ticker, cik, composite_figi, or share_class_figi. Provide exactly one of these fields.
 */
export const instrumentsDetailRetrieveOptions = (options?: Options<InstrumentsDetailRetrieveData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await instrumentsDetailRetrieve({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: instrumentsDetailRetrieveQueryKey(options)
    });
};

export const instrumentsWithPricesListQueryKey = (options?: Options<InstrumentsWithPricesListData>) => createQueryKey('instrumentsWithPricesList', options);

export const instrumentsWithPricesListOptions = (options?: Options<InstrumentsWithPricesListData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await instrumentsWithPricesList({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: instrumentsWithPricesListQueryKey(options)
    });
};

export const instrumentsWithPricesListInfiniteQueryKey = (options?: Options<InstrumentsWithPricesListData>): QueryKey<Options<InstrumentsWithPricesListData>> => createQueryKey('instrumentsWithPricesList', options, true);

export const instrumentsWithPricesListInfiniteOptions = (options?: Options<InstrumentsWithPricesListData>) => {
    return infiniteQueryOptions<InstrumentsWithPricesListResponse, DefaultError, InfiniteData<InstrumentsWithPricesListResponse>, QueryKey<Options<InstrumentsWithPricesListData>>, number | Pick<QueryKey<Options<InstrumentsWithPricesListData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<InstrumentsWithPricesListData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await instrumentsWithPricesList({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: instrumentsWithPricesListInfiniteQueryKey(options)
    });
};

export const investorsListQueryKey = (options?: Options<InvestorsListData>) => createQueryKey('investorsList', options);

/**
 * List investors
 * Get a paginated list of investors with optional search filtering.
 */
export const investorsListOptions = (options?: Options<InvestorsListData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await investorsList({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: investorsListQueryKey(options)
    });
};

export const investorsListInfiniteQueryKey = (options?: Options<InvestorsListData>): QueryKey<Options<InvestorsListData>> => createQueryKey('investorsList', options, true);

/**
 * List investors
 * Get a paginated list of investors with optional search filtering.
 */
export const investorsListInfiniteOptions = (options?: Options<InvestorsListData>) => {
    return infiniteQueryOptions<InvestorsListResponse, DefaultError, InfiniteData<InvestorsListResponse>, QueryKey<Options<InvestorsListData>>, number | Pick<QueryKey<Options<InvestorsListData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<InvestorsListData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await investorsList({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: investorsListInfiniteQueryKey(options)
    });
};

export const investorsRetrieveQueryKey = (options: Options<InvestorsRetrieveData>) => createQueryKey('investorsRetrieve', options);

/**
 * Get investor
 * Retrieve a specific investor by ID.
 */
export const investorsRetrieveOptions = (options: Options<InvestorsRetrieveData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await investorsRetrieve({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: investorsRetrieveQueryKey(options)
    });
};

/**
 * Partially update investor
 * Partially update an investor's information.
 */
export const investorsPartialUpdateMutation = (options?: Partial<Options<InvestorsPartialUpdateData>>): UseMutationOptions<InvestorsPartialUpdateResponse, DefaultError, Options<InvestorsPartialUpdateData>> => {
    const mutationOptions: UseMutationOptions<InvestorsPartialUpdateResponse, DefaultError, Options<InvestorsPartialUpdateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await investorsPartialUpdate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update investor
 * Update an investor's information.
 */
export const investorsUpdateMutation = (options?: Partial<Options<InvestorsUpdateData>>): UseMutationOptions<InvestorsUpdateResponse, DefaultError, Options<InvestorsUpdateData>> => {
    const mutationOptions: UseMutationOptions<InvestorsUpdateResponse, DefaultError, Options<InvestorsUpdateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await investorsUpdate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const investorsMeRetrieveQueryKey = (options?: Options<InvestorsMeRetrieveData>) => createQueryKey('investorsMeRetrieve', options);

/**
 * Get current investor
 * Get the investor profile for the currently authenticated user.
 */
export const investorsMeRetrieveOptions = (options?: Options<InvestorsMeRetrieveData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await investorsMeRetrieve({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: investorsMeRetrieveQueryKey(options)
    });
};

export const investorsMeAccountValueListQueryKey = (options?: Options<InvestorsMeAccountValueListData>) => createQueryKey('investorsMeAccountValueList', options);

/**
 * Get account value over time
 * Get account value over time data for the currently authenticated user.
 */
export const investorsMeAccountValueListOptions = (options?: Options<InvestorsMeAccountValueListData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await investorsMeAccountValueList({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: investorsMeAccountValueListQueryKey(options)
    });
};

export const investorsMeAssetAllocationRetrieveQueryKey = (options?: Options<InvestorsMeAssetAllocationRetrieveData>) => createQueryKey('investorsMeAssetAllocationRetrieve', options);

/**
 * Get asset allocation
 * Get asset allocation data for the currently authenticated user.
 */
export const investorsMeAssetAllocationRetrieveOptions = (options?: Options<InvestorsMeAssetAllocationRetrieveData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await investorsMeAssetAllocationRetrieve({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: investorsMeAssetAllocationRetrieveQueryKey(options)
    });
};

export const investorsMeCurrentAccountValueRetrieveQueryKey = (options?: Options<InvestorsMeCurrentAccountValueRetrieveData>) => createQueryKey('investorsMeCurrentAccountValueRetrieve', options);

/**
 * Get current account value
 * Get the current account value as well as gain and percent gain for the authenticated user.
 */
export const investorsMeCurrentAccountValueRetrieveOptions = (options?: Options<InvestorsMeCurrentAccountValueRetrieveData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await investorsMeCurrentAccountValueRetrieve({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: investorsMeCurrentAccountValueRetrieveQueryKey(options)
    });
};

export const investorsMeOwnedSharesRetrieveQueryKey = (options?: Options<InvestorsMeOwnedSharesRetrieveData>) => createQueryKey('investorsMeOwnedSharesRetrieve', options);

/**
 * Get owned shares
 * Get owned shares data for the currently authenticated user.
 */
export const investorsMeOwnedSharesRetrieveOptions = (options?: Options<InvestorsMeOwnedSharesRetrieveData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await investorsMeOwnedSharesRetrieve({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: investorsMeOwnedSharesRetrieveQueryKey(options)
    });
};

export const investorsMeStatisticsMostTradedListQueryKey = (options?: Options<InvestorsMeStatisticsMostTradedListData>) => createQueryKey('investorsMeStatisticsMostTradedList', options);

/**
 * Get overview about the most traded instruments
 * Returns number of trades, number of buys/sells, avg gain/loss, and total return from the most frequently traded instruments.
 */
export const investorsMeStatisticsMostTradedListOptions = (options?: Options<InvestorsMeStatisticsMostTradedListData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await investorsMeStatisticsMostTradedList({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: investorsMeStatisticsMostTradedListQueryKey(options)
    });
};

export const investorsMeStatisticsMostTradedListInfiniteQueryKey = (options?: Options<InvestorsMeStatisticsMostTradedListData>): QueryKey<Options<InvestorsMeStatisticsMostTradedListData>> => createQueryKey('investorsMeStatisticsMostTradedList', options, true);

/**
 * Get overview about the most traded instruments
 * Returns number of trades, number of buys/sells, avg gain/loss, and total return from the most frequently traded instruments.
 */
export const investorsMeStatisticsMostTradedListInfiniteOptions = (options?: Options<InvestorsMeStatisticsMostTradedListData>) => {
    return infiniteQueryOptions<InvestorsMeStatisticsMostTradedListResponse, DefaultError, InfiniteData<InvestorsMeStatisticsMostTradedListResponse>, QueryKey<Options<InvestorsMeStatisticsMostTradedListData>>, number | Pick<QueryKey<Options<InvestorsMeStatisticsMostTradedListData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<InvestorsMeStatisticsMostTradedListData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await investorsMeStatisticsMostTradedList({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: investorsMeStatisticsMostTradedListInfiniteQueryKey(options)
    });
};

export const investorsMeStatisticsProfileOverviewRetrieveQueryKey = (options?: Options<InvestorsMeStatisticsProfileOverviewRetrieveData>) => createQueryKey('investorsMeStatisticsProfileOverviewRetrieve', options);

/**
 * Get info about investor's level
 * Get the information about the level, exp points and points left to next level for the current investor
 */
export const investorsMeStatisticsProfileOverviewRetrieveOptions = (options?: Options<InvestorsMeStatisticsProfileOverviewRetrieveData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await investorsMeStatisticsProfileOverviewRetrieve({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: investorsMeStatisticsProfileOverviewRetrieveQueryKey(options)
    });
};

export const investorsMeStatisticsTradingOverviewRetrieveQueryKey = (options?: Options<InvestorsMeStatisticsTradingOverviewRetrieveData>) => createQueryKey('investorsMeStatisticsTradingOverviewRetrieve', options);

/**
 * Get trading performance overview
 * Returns total trades, number of buys/sells, average gain/loss, and total return for the current investor.
 */
export const investorsMeStatisticsTradingOverviewRetrieveOptions = (options?: Options<InvestorsMeStatisticsTradingOverviewRetrieveData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await investorsMeStatisticsTradingOverviewRetrieve({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: investorsMeStatisticsTradingOverviewRetrieveQueryKey(options)
    });
};

export const investorsMeStatsRetrieveQueryKey = (options?: Options<InvestorsMeStatsRetrieveData>) => createQueryKey('investorsMeStatsRetrieve', options);

/**
 * Get investor stats
 * Get investor statistics for the currently authenticated user.
 */
export const investorsMeStatsRetrieveOptions = (options?: Options<InvestorsMeStatsRetrieveData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await investorsMeStatsRetrieve({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: investorsMeStatsRetrieveQueryKey(options)
    });
};

export const investorsMeTransactionsHistoryListQueryKey = (options?: Options<InvestorsMeTransactionsHistoryListData>) => createQueryKey('investorsMeTransactionsHistoryList', options);

/**
 * Get transaction history
 * Get transaction history for the currently authenticated user. Can filter by position type (open/closed/both) and ticker symbol.
 */
export const investorsMeTransactionsHistoryListOptions = (options?: Options<InvestorsMeTransactionsHistoryListData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await investorsMeTransactionsHistoryList({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: investorsMeTransactionsHistoryListQueryKey(options)
    });
};

export const marketsHolidaysListQueryKey = (options?: Options<MarketsHolidaysListData>) => createQueryKey('marketsHolidaysList', options);

/**
 * Retrieve a list of upcoming market holidays.
 */
export const marketsHolidaysListOptions = (options?: Options<MarketsHolidaysListData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await marketsHolidaysList({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: marketsHolidaysListQueryKey(options)
    });
};

export const marketsStatusRetrieveQueryKey = (options?: Options<MarketsStatusRetrieveData>) => createQueryKey('marketsStatusRetrieve', options);

/**
 * Retrieve the current trading status of the markets and exchanges.
 */
export const marketsStatusRetrieveOptions = (options?: Options<MarketsStatusRetrieveData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await marketsStatusRetrieve({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: marketsStatusRetrieveQueryKey(options)
    });
};

export const newsListQueryKey = (options?: Options<NewsListData>) => createQueryKey('newsList', options);

/**
 * Retrieve a list of 30 news articles.
 */
export const newsListOptions = (options?: Options<NewsListData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await newsList({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: newsListQueryKey(options)
    });
};

export const ordersListQueryKey = (options?: Options<OrdersListData>) => createQueryKey('ordersList', options);

export const ordersListOptions = (options?: Options<OrdersListData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await ordersList({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: ordersListQueryKey(options)
    });
};

export const ordersListInfiniteQueryKey = (options?: Options<OrdersListData>): QueryKey<Options<OrdersListData>> => createQueryKey('ordersList', options, true);

export const ordersListInfiniteOptions = (options?: Options<OrdersListData>) => {
    return infiniteQueryOptions<OrdersListResponse, DefaultError, InfiniteData<OrdersListResponse>, QueryKey<Options<OrdersListData>>, number | Pick<QueryKey<Options<OrdersListData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<OrdersListData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await ordersList({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: ordersListInfiniteQueryKey(options)
    });
};

export const ordersCancelDestroyMutation = (options?: Partial<Options<OrdersCancelDestroyData>>): UseMutationOptions<OrdersCancelDestroyResponse, DefaultError, Options<OrdersCancelDestroyData>> => {
    const mutationOptions: UseMutationOptions<OrdersCancelDestroyResponse, DefaultError, Options<OrdersCancelDestroyData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await ordersCancelDestroy({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const ordersMarketCreateMutation = (options?: Partial<Options<OrdersMarketCreateData>>): UseMutationOptions<OrdersMarketCreateResponse, DefaultError, Options<OrdersMarketCreateData>> => {
    const mutationOptions: UseMutationOptions<OrdersMarketCreateResponse, DefaultError, Options<OrdersMarketCreateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await ordersMarketCreate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const pricesListQueryKey = (options: Options<PricesListData>) => createQueryKey('pricesList', options);

export const pricesListOptions = (options: Options<PricesListData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await pricesList({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: pricesListQueryKey(options)
    });
};

export const pricesRetrieveQueryKey = (options: Options<PricesRetrieveData>) => createQueryKey('pricesRetrieve', options);

export const pricesRetrieveOptions = (options: Options<PricesRetrieveData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await pricesRetrieve({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: pricesRetrieveQueryKey(options)
    });
};

export const pricesBarsQueryKey = (options: Options<PricesBarsData>) => createQueryKey('pricesBars', options);

export const pricesBarsOptions = (options: Options<PricesBarsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await pricesBars({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: pricesBarsQueryKey(options)
    });
};

export const statusRetrieveQueryKey = (options?: Options<StatusRetrieveData>) => createQueryKey('statusRetrieve', options);

/**
 * Get application status
 * Returns a simple status message indicating the application is running.
 */
export const statusRetrieveOptions = (options?: Options<StatusRetrieveData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await statusRetrieve({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: statusRetrieveQueryKey(options)
    });
};

export const testAdminTestRetrieveQueryKey = (options?: Options<TestAdminTestRetrieveData>) => createQueryKey('testAdminTestRetrieve', options);

/**
 * Test admin authentication
 * Test endpoint to verify admin authentication is working.
 */
export const testAdminTestRetrieveOptions = (options?: Options<TestAdminTestRetrieveData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await testAdminTestRetrieve({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: testAdminTestRetrieveQueryKey(options)
    });
};

export const testAllTestRetrieveQueryKey = (options?: Options<TestAllTestRetrieveData>) => createQueryKey('testAllTestRetrieve', options);

/**
 * Test unauthenticated endpoint
 * Test endpoint that doesn't require authentication.
 */
export const testAllTestRetrieveOptions = (options?: Options<TestAllTestRetrieveData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await testAllTestRetrieve({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: testAllTestRetrieveQueryKey(options)
    });
};

export const testAlpacaTestRetrieveQueryKey = (options?: Options<TestAlpacaTestRetrieveData>) => createQueryKey('testAlpacaTestRetrieve', options);

/**
 * Fetch last trade from Alpaca
 * test alpaca.
 */
export const testAlpacaTestRetrieveOptions = (options?: Options<TestAlpacaTestRetrieveData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await testAlpacaTestRetrieve({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: testAlpacaTestRetrieveQueryKey(options)
    });
};

export const testPolygonTestRetrieveQueryKey = (options?: Options<TestPolygonTestRetrieveData>) => createQueryKey('testPolygonTestRetrieve', options);

/**
 * Fetch last trade from Polygon.io
 * test polygon.
 */
export const testPolygonTestRetrieveOptions = (options?: Options<TestPolygonTestRetrieveData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await testPolygonTestRetrieve({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: testPolygonTestRetrieveQueryKey(options)
    });
};

export const testUsersTestRetrieveQueryKey = (options?: Options<TestUsersTestRetrieveData>) => createQueryKey('testUsersTestRetrieve', options);

/**
 * Test user authentication
 * Test endpoint to verify user authentication is working.
 */
export const testUsersTestRetrieveOptions = (options?: Options<TestUsersTestRetrieveData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await testUsersTestRetrieve({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: testUsersTestRetrieveQueryKey(options)
    });
};
