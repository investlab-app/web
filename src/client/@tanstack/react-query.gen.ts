// This file is auto-generated by @hey-api/openapi-ts

import { type DefaultError, type InfiniteData, infiniteQueryOptions, queryOptions, type UseMutationOptions } from '@tanstack/react-query';

import { client } from '../client.gen';
import { authSignInCreate, graphLangCreate, graphLangDestroy, graphLangList, graphLangPartialUpdate, graphLangResultsList, graphLangRetrieve, graphLangRunCreate, graphLangUpdate, instrumentsDetailRetrieve, instrumentsList, instrumentsWithPricesList, investorsDepositCreate, investorsMeAccountValueList, investorsMeNotificationsList, investorsMePartialUpdate, investorsMeRetrieve, investorsMeWatchedTickersList, investorsMeWatchedTickersPartialUpdate, investorsPartialUpdate, investorsRetrieve, marketsHolidaysList, marketsStatusRetrieve, newsList, notificationsVapidPublicKeyRetrieve, type Options, ordersCancelDestroy, ordersLimitCreate, ordersLimitList, ordersList, ordersMarketCreate, ordersMarketList, pricesBars, pricesList, pricesPriceAlertCreate, pricesPriceAlertDestroy, pricesPriceAlertList, pricesPriceAlertPartialUpdate, pricesPriceAlertRetrieve, pricesPriceAlertUpdate, pricesRetrieve, statisticsAssetAllocationRetrieve, statisticsCurrentAccountValueRetrieve, statisticsOwnedSharesList, statisticsStatisticsMostTradedList, statisticsStatisticsTradingOverviewRetrieve, statisticsStatsRetrieve, statisticsTransactionsHistoryList, statusRetrieve, testAdminTestRetrieve, testAllTestRetrieve, testAlpacaTestRetrieve, testPolygonTestRetrieve, testUsersTestRetrieve } from '../sdk.gen';
import type { AuthSignInCreateData, GraphLangCreateData, GraphLangCreateResponse, GraphLangDestroyData, GraphLangDestroyResponse, GraphLangListData, GraphLangListResponse, GraphLangPartialUpdateData, GraphLangPartialUpdateResponse, GraphLangResultsListData, GraphLangResultsListResponse, GraphLangRetrieveData, GraphLangRunCreateData, GraphLangRunCreateResponse, GraphLangUpdateData, GraphLangUpdateResponse, InstrumentsDetailRetrieveData, InstrumentsListData, InstrumentsListResponse, InstrumentsWithPricesListData, InstrumentsWithPricesListResponse, InvestorsDepositCreateData, InvestorsDepositCreateResponse, InvestorsMeAccountValueListData, InvestorsMeNotificationsListData, InvestorsMePartialUpdateData, InvestorsMePartialUpdateResponse, InvestorsMeRetrieveData, InvestorsMeWatchedTickersListData, InvestorsMeWatchedTickersPartialUpdateData, InvestorsMeWatchedTickersPartialUpdateResponse, InvestorsPartialUpdateData, InvestorsPartialUpdateResponse, InvestorsRetrieveData, MarketsHolidaysListData, MarketsStatusRetrieveData, NewsListData, NotificationsVapidPublicKeyRetrieveData, OrdersCancelDestroyData, OrdersCancelDestroyResponse, OrdersLimitCreateData, OrdersLimitCreateResponse, OrdersLimitListData, OrdersListData, OrdersMarketCreateData, OrdersMarketCreateResponse, OrdersMarketListData, PricesBarsData, PricesListData, PricesPriceAlertCreateData, PricesPriceAlertCreateResponse, PricesPriceAlertDestroyData, PricesPriceAlertDestroyResponse, PricesPriceAlertListData, PricesPriceAlertListResponse, PricesPriceAlertPartialUpdateData, PricesPriceAlertPartialUpdateResponse, PricesPriceAlertRetrieveData, PricesPriceAlertUpdateData, PricesPriceAlertUpdateResponse, PricesRetrieveData, StatisticsAssetAllocationRetrieveData, StatisticsCurrentAccountValueRetrieveData, StatisticsOwnedSharesListData, StatisticsStatisticsMostTradedListData, StatisticsStatisticsTradingOverviewRetrieveData, StatisticsStatsRetrieveData, StatisticsTransactionsHistoryListData, StatusRetrieveData, TestAdminTestRetrieveData, TestAllTestRetrieveData, TestAlpacaTestRetrieveData, TestPolygonTestRetrieveData, TestUsersTestRetrieveData } from '../types.gen';

/**
 * Sign in a user with email and password via Clerk
 * Authenticates a user using their email and password through Clerk, returning a sign-in token upon success.
 */
export const authSignInCreateMutation = (options?: Partial<Options<AuthSignInCreateData>>): UseMutationOptions<unknown, DefaultError, Options<AuthSignInCreateData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<AuthSignInCreateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await authSignInCreate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export type QueryKey<TOptions extends Options> = [
    Pick<TOptions, 'baseUrl' | 'body' | 'headers' | 'path' | 'query'> & {
        _id: string;
        _infinite?: boolean;
        tags?: ReadonlyArray<string>;
    }
];

const createQueryKey = <TOptions extends Options>(id: string, options?: TOptions, infinite?: boolean, tags?: ReadonlyArray<string>): [
    QueryKey<TOptions>[0]
] => {
    const params: QueryKey<TOptions>[0] = { _id: id, baseUrl: options?.baseUrl || (options?.client ?? client).getConfig().baseUrl } as QueryKey<TOptions>[0];
    if (infinite) {
        params._infinite = infinite;
    }
    if (tags) {
        params.tags = tags;
    }
    if (options?.body) {
        params.body = options.body;
    }
    if (options?.headers) {
        params.headers = options.headers;
    }
    if (options?.path) {
        params.path = options.path;
    }
    if (options?.query) {
        params.query = options.query;
    }
    return [
        params
    ];
};

export const graphLangListQueryKey = (options?: Options<GraphLangListData>) => createQueryKey('graphLangList', options);

export const graphLangListOptions = (options?: Options<GraphLangListData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await graphLangList({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: graphLangListQueryKey(options)
    });
};

const createInfiniteParams = <K extends Pick<QueryKey<Options>[0], 'body' | 'headers' | 'path' | 'query'>>(queryKey: QueryKey<Options>, page: K) => {
    const params = {
        ...queryKey[0]
    };
    if (page.body) {
        params.body = {
            ...queryKey[0].body as any,
            ...page.body as any
        };
    }
    if (page.headers) {
        params.headers = {
            ...queryKey[0].headers,
            ...page.headers
        };
    }
    if (page.path) {
        params.path = {
            ...queryKey[0].path as any,
            ...page.path as any
        };
    }
    if (page.query) {
        params.query = {
            ...queryKey[0].query as any,
            ...page.query as any
        };
    }
    return params as unknown as typeof page;
};

export const graphLangListInfiniteQueryKey = (options?: Options<GraphLangListData>): QueryKey<Options<GraphLangListData>> => createQueryKey('graphLangList', options, true);

export const graphLangListInfiniteOptions = (options?: Options<GraphLangListData>) => {
    return infiniteQueryOptions<GraphLangListResponse, DefaultError, InfiniteData<GraphLangListResponse>, QueryKey<Options<GraphLangListData>>, number | Pick<QueryKey<Options<GraphLangListData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GraphLangListData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await graphLangList({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: graphLangListInfiniteQueryKey(options)
    });
};

export const graphLangCreateMutation = (options?: Partial<Options<GraphLangCreateData>>): UseMutationOptions<GraphLangCreateResponse, DefaultError, Options<GraphLangCreateData>> => {
    const mutationOptions: UseMutationOptions<GraphLangCreateResponse, DefaultError, Options<GraphLangCreateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await graphLangCreate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const graphLangDestroyMutation = (options?: Partial<Options<GraphLangDestroyData>>): UseMutationOptions<GraphLangDestroyResponse, DefaultError, Options<GraphLangDestroyData>> => {
    const mutationOptions: UseMutationOptions<GraphLangDestroyResponse, DefaultError, Options<GraphLangDestroyData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await graphLangDestroy({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const graphLangRetrieveQueryKey = (options: Options<GraphLangRetrieveData>) => createQueryKey('graphLangRetrieve', options);

export const graphLangRetrieveOptions = (options: Options<GraphLangRetrieveData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await graphLangRetrieve({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: graphLangRetrieveQueryKey(options)
    });
};

export const graphLangPartialUpdateMutation = (options?: Partial<Options<GraphLangPartialUpdateData>>): UseMutationOptions<GraphLangPartialUpdateResponse, DefaultError, Options<GraphLangPartialUpdateData>> => {
    const mutationOptions: UseMutationOptions<GraphLangPartialUpdateResponse, DefaultError, Options<GraphLangPartialUpdateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await graphLangPartialUpdate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const graphLangUpdateMutation = (options?: Partial<Options<GraphLangUpdateData>>): UseMutationOptions<GraphLangUpdateResponse, DefaultError, Options<GraphLangUpdateData>> => {
    const mutationOptions: UseMutationOptions<GraphLangUpdateResponse, DefaultError, Options<GraphLangUpdateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await graphLangUpdate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const graphLangResultsListQueryKey = (options: Options<GraphLangResultsListData>) => createQueryKey('graphLangResultsList', options);

export const graphLangResultsListOptions = (options: Options<GraphLangResultsListData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await graphLangResultsList({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: graphLangResultsListQueryKey(options)
    });
};

export const graphLangResultsListInfiniteQueryKey = (options: Options<GraphLangResultsListData>): QueryKey<Options<GraphLangResultsListData>> => createQueryKey('graphLangResultsList', options, true);

export const graphLangResultsListInfiniteOptions = (options: Options<GraphLangResultsListData>) => {
    return infiniteQueryOptions<GraphLangResultsListResponse, DefaultError, InfiniteData<GraphLangResultsListResponse>, QueryKey<Options<GraphLangResultsListData>>, number | Pick<QueryKey<Options<GraphLangResultsListData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GraphLangResultsListData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await graphLangResultsList({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: graphLangResultsListInfiniteQueryKey(options)
    });
};

export const graphLangRunCreateMutation = (options?: Partial<Options<GraphLangRunCreateData>>): UseMutationOptions<GraphLangRunCreateResponse, DefaultError, Options<GraphLangRunCreateData>> => {
    const mutationOptions: UseMutationOptions<GraphLangRunCreateResponse, DefaultError, Options<GraphLangRunCreateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await graphLangRunCreate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const instrumentsListQueryKey = (options?: Options<InstrumentsListData>) => createQueryKey('instrumentsList', options);

export const instrumentsListOptions = (options?: Options<InstrumentsListData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await instrumentsList({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: instrumentsListQueryKey(options)
    });
};

export const instrumentsListInfiniteQueryKey = (options?: Options<InstrumentsListData>): QueryKey<Options<InstrumentsListData>> => createQueryKey('instrumentsList', options, true);

export const instrumentsListInfiniteOptions = (options?: Options<InstrumentsListData>) => {
    return infiniteQueryOptions<InstrumentsListResponse, DefaultError, InfiniteData<InstrumentsListResponse>, QueryKey<Options<InstrumentsListData>>, number | Pick<QueryKey<Options<InstrumentsListData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<InstrumentsListData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await instrumentsList({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: instrumentsListInfiniteQueryKey(options)
    });
};

export const instrumentsDetailRetrieveQueryKey = (options?: Options<InstrumentsDetailRetrieveData>) => createQueryKey('instrumentsDetailRetrieve', options);

/**
 * Retrieve an instrument by one of the following query parameters: id, ticker, cik, composite_figi, or share_class_figi. Provide exactly one of these fields.
 */
export const instrumentsDetailRetrieveOptions = (options?: Options<InstrumentsDetailRetrieveData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await instrumentsDetailRetrieve({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: instrumentsDetailRetrieveQueryKey(options)
    });
};

export const instrumentsWithPricesListQueryKey = (options?: Options<InstrumentsWithPricesListData>) => createQueryKey('instrumentsWithPricesList', options);

export const instrumentsWithPricesListOptions = (options?: Options<InstrumentsWithPricesListData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await instrumentsWithPricesList({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: instrumentsWithPricesListQueryKey(options)
    });
};

export const instrumentsWithPricesListInfiniteQueryKey = (options?: Options<InstrumentsWithPricesListData>): QueryKey<Options<InstrumentsWithPricesListData>> => createQueryKey('instrumentsWithPricesList', options, true);

export const instrumentsWithPricesListInfiniteOptions = (options?: Options<InstrumentsWithPricesListData>) => {
    return infiniteQueryOptions<InstrumentsWithPricesListResponse, DefaultError, InfiniteData<InstrumentsWithPricesListResponse>, QueryKey<Options<InstrumentsWithPricesListData>>, number | Pick<QueryKey<Options<InstrumentsWithPricesListData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<InstrumentsWithPricesListData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await instrumentsWithPricesList({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: instrumentsWithPricesListInfiniteQueryKey(options)
    });
};

export const investorsRetrieveQueryKey = (options: Options<InvestorsRetrieveData>) => createQueryKey('investorsRetrieve', options);

export const investorsRetrieveOptions = (options: Options<InvestorsRetrieveData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await investorsRetrieve({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: investorsRetrieveQueryKey(options)
    });
};

export const investorsPartialUpdateMutation = (options?: Partial<Options<InvestorsPartialUpdateData>>): UseMutationOptions<InvestorsPartialUpdateResponse, DefaultError, Options<InvestorsPartialUpdateData>> => {
    const mutationOptions: UseMutationOptions<InvestorsPartialUpdateResponse, DefaultError, Options<InvestorsPartialUpdateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await investorsPartialUpdate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const investorsDepositCreateMutation = (options?: Partial<Options<InvestorsDepositCreateData>>): UseMutationOptions<InvestorsDepositCreateResponse, DefaultError, Options<InvestorsDepositCreateData>> => {
    const mutationOptions: UseMutationOptions<InvestorsDepositCreateResponse, DefaultError, Options<InvestorsDepositCreateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await investorsDepositCreate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const investorsMeRetrieveQueryKey = (options?: Options<InvestorsMeRetrieveData>) => createQueryKey('investorsMeRetrieve', options);

/**
 * Get current investor
 * Get the investor profile for the currently authenticated user.
 */
export const investorsMeRetrieveOptions = (options?: Options<InvestorsMeRetrieveData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await investorsMeRetrieve({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: investorsMeRetrieveQueryKey(options)
    });
};

/**
 * Update current investor
 * Update the investor profile for the currently authenticated user.
 */
export const investorsMePartialUpdateMutation = (options?: Partial<Options<InvestorsMePartialUpdateData>>): UseMutationOptions<InvestorsMePartialUpdateResponse, DefaultError, Options<InvestorsMePartialUpdateData>> => {
    const mutationOptions: UseMutationOptions<InvestorsMePartialUpdateResponse, DefaultError, Options<InvestorsMePartialUpdateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await investorsMePartialUpdate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const investorsMeAccountValueListQueryKey = (options?: Options<InvestorsMeAccountValueListData>) => createQueryKey('investorsMeAccountValueList', options);

/**
 * Get account value over time
 * Get account value over time data for the currently authenticated user.
 */
export const investorsMeAccountValueListOptions = (options?: Options<InvestorsMeAccountValueListData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await investorsMeAccountValueList({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: investorsMeAccountValueListQueryKey(options)
    });
};

export const investorsMeNotificationsListQueryKey = (options?: Options<InvestorsMeNotificationsListData>) => createQueryKey('investorsMeNotificationsList', options);

export const investorsMeNotificationsListOptions = (options?: Options<InvestorsMeNotificationsListData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await investorsMeNotificationsList({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: investorsMeNotificationsListQueryKey(options)
    });
};

export const investorsMeWatchedTickersListQueryKey = (options?: Options<InvestorsMeWatchedTickersListData>) => createQueryKey('investorsMeWatchedTickersList', options);

export const investorsMeWatchedTickersListOptions = (options?: Options<InvestorsMeWatchedTickersListData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await investorsMeWatchedTickersList({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: investorsMeWatchedTickersListQueryKey(options)
    });
};

export const investorsMeWatchedTickersPartialUpdateMutation = (options?: Partial<Options<InvestorsMeWatchedTickersPartialUpdateData>>): UseMutationOptions<InvestorsMeWatchedTickersPartialUpdateResponse, DefaultError, Options<InvestorsMeWatchedTickersPartialUpdateData>> => {
    const mutationOptions: UseMutationOptions<InvestorsMeWatchedTickersPartialUpdateResponse, DefaultError, Options<InvestorsMeWatchedTickersPartialUpdateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await investorsMeWatchedTickersPartialUpdate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const marketsHolidaysListQueryKey = (options?: Options<MarketsHolidaysListData>) => createQueryKey('marketsHolidaysList', options);

/**
 * Retrieve a list of upcoming market holidays.
 */
export const marketsHolidaysListOptions = (options?: Options<MarketsHolidaysListData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await marketsHolidaysList({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: marketsHolidaysListQueryKey(options)
    });
};

export const marketsStatusRetrieveQueryKey = (options?: Options<MarketsStatusRetrieveData>) => createQueryKey('marketsStatusRetrieve', options);

/**
 * Retrieve the current trading status of the markets and exchanges.
 */
export const marketsStatusRetrieveOptions = (options?: Options<MarketsStatusRetrieveData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await marketsStatusRetrieve({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: marketsStatusRetrieveQueryKey(options)
    });
};

export const newsListQueryKey = (options?: Options<NewsListData>) => createQueryKey('newsList', options);

/**
 * Retrieve a list of 30 news articles.
 */
export const newsListOptions = (options?: Options<NewsListData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await newsList({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: newsListQueryKey(options)
    });
};

export const notificationsVapidPublicKeyRetrieveQueryKey = (options?: Options<NotificationsVapidPublicKeyRetrieveData>) => createQueryKey('notificationsVapidPublicKeyRetrieve', options);

export const notificationsVapidPublicKeyRetrieveOptions = (options?: Options<NotificationsVapidPublicKeyRetrieveData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await notificationsVapidPublicKeyRetrieve({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: notificationsVapidPublicKeyRetrieveQueryKey(options)
    });
};

export const ordersListQueryKey = (options?: Options<OrdersListData>) => createQueryKey('ordersList', options);

export const ordersListOptions = (options?: Options<OrdersListData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await ordersList({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: ordersListQueryKey(options)
    });
};

export const ordersCancelDestroyMutation = (options?: Partial<Options<OrdersCancelDestroyData>>): UseMutationOptions<OrdersCancelDestroyResponse, DefaultError, Options<OrdersCancelDestroyData>> => {
    const mutationOptions: UseMutationOptions<OrdersCancelDestroyResponse, DefaultError, Options<OrdersCancelDestroyData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await ordersCancelDestroy({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const ordersLimitListQueryKey = (options?: Options<OrdersLimitListData>) => createQueryKey('ordersLimitList', options);

export const ordersLimitListOptions = (options?: Options<OrdersLimitListData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await ordersLimitList({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: ordersLimitListQueryKey(options)
    });
};

export const ordersLimitCreateMutation = (options?: Partial<Options<OrdersLimitCreateData>>): UseMutationOptions<OrdersLimitCreateResponse, DefaultError, Options<OrdersLimitCreateData>> => {
    const mutationOptions: UseMutationOptions<OrdersLimitCreateResponse, DefaultError, Options<OrdersLimitCreateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await ordersLimitCreate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const ordersMarketListQueryKey = (options?: Options<OrdersMarketListData>) => createQueryKey('ordersMarketList', options);

export const ordersMarketListOptions = (options?: Options<OrdersMarketListData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await ordersMarketList({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: ordersMarketListQueryKey(options)
    });
};

export const ordersMarketCreateMutation = (options?: Partial<Options<OrdersMarketCreateData>>): UseMutationOptions<OrdersMarketCreateResponse, DefaultError, Options<OrdersMarketCreateData>> => {
    const mutationOptions: UseMutationOptions<OrdersMarketCreateResponse, DefaultError, Options<OrdersMarketCreateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await ordersMarketCreate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const pricesListQueryKey = (options: Options<PricesListData>) => createQueryKey('pricesList', options);

export const pricesListOptions = (options: Options<PricesListData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await pricesList({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: pricesListQueryKey(options)
    });
};

export const pricesRetrieveQueryKey = (options: Options<PricesRetrieveData>) => createQueryKey('pricesRetrieve', options);

export const pricesRetrieveOptions = (options: Options<PricesRetrieveData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await pricesRetrieve({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: pricesRetrieveQueryKey(options)
    });
};

export const pricesBarsQueryKey = (options: Options<PricesBarsData>) => createQueryKey('pricesBars', options);

export const pricesBarsOptions = (options: Options<PricesBarsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await pricesBars({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: pricesBarsQueryKey(options)
    });
};

export const pricesPriceAlertListQueryKey = (options?: Options<PricesPriceAlertListData>) => createQueryKey('pricesPriceAlertList', options);

export const pricesPriceAlertListOptions = (options?: Options<PricesPriceAlertListData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await pricesPriceAlertList({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: pricesPriceAlertListQueryKey(options)
    });
};

export const pricesPriceAlertListInfiniteQueryKey = (options?: Options<PricesPriceAlertListData>): QueryKey<Options<PricesPriceAlertListData>> => createQueryKey('pricesPriceAlertList', options, true);

export const pricesPriceAlertListInfiniteOptions = (options?: Options<PricesPriceAlertListData>) => {
    return infiniteQueryOptions<PricesPriceAlertListResponse, DefaultError, InfiniteData<PricesPriceAlertListResponse>, QueryKey<Options<PricesPriceAlertListData>>, number | Pick<QueryKey<Options<PricesPriceAlertListData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<PricesPriceAlertListData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await pricesPriceAlertList({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: pricesPriceAlertListInfiniteQueryKey(options)
    });
};

export const pricesPriceAlertCreateMutation = (options?: Partial<Options<PricesPriceAlertCreateData>>): UseMutationOptions<PricesPriceAlertCreateResponse, DefaultError, Options<PricesPriceAlertCreateData>> => {
    const mutationOptions: UseMutationOptions<PricesPriceAlertCreateResponse, DefaultError, Options<PricesPriceAlertCreateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await pricesPriceAlertCreate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const pricesPriceAlertDestroyMutation = (options?: Partial<Options<PricesPriceAlertDestroyData>>): UseMutationOptions<PricesPriceAlertDestroyResponse, DefaultError, Options<PricesPriceAlertDestroyData>> => {
    const mutationOptions: UseMutationOptions<PricesPriceAlertDestroyResponse, DefaultError, Options<PricesPriceAlertDestroyData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await pricesPriceAlertDestroy({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const pricesPriceAlertRetrieveQueryKey = (options: Options<PricesPriceAlertRetrieveData>) => createQueryKey('pricesPriceAlertRetrieve', options);

export const pricesPriceAlertRetrieveOptions = (options: Options<PricesPriceAlertRetrieveData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await pricesPriceAlertRetrieve({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: pricesPriceAlertRetrieveQueryKey(options)
    });
};

export const pricesPriceAlertPartialUpdateMutation = (options?: Partial<Options<PricesPriceAlertPartialUpdateData>>): UseMutationOptions<PricesPriceAlertPartialUpdateResponse, DefaultError, Options<PricesPriceAlertPartialUpdateData>> => {
    const mutationOptions: UseMutationOptions<PricesPriceAlertPartialUpdateResponse, DefaultError, Options<PricesPriceAlertPartialUpdateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await pricesPriceAlertPartialUpdate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const pricesPriceAlertUpdateMutation = (options?: Partial<Options<PricesPriceAlertUpdateData>>): UseMutationOptions<PricesPriceAlertUpdateResponse, DefaultError, Options<PricesPriceAlertUpdateData>> => {
    const mutationOptions: UseMutationOptions<PricesPriceAlertUpdateResponse, DefaultError, Options<PricesPriceAlertUpdateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await pricesPriceAlertUpdate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const statisticsAssetAllocationRetrieveQueryKey = (options?: Options<StatisticsAssetAllocationRetrieveData>) => createQueryKey('statisticsAssetAllocationRetrieve', options);

/**
 * Get asset allocation
 * Get asset allocation data for the currently authenticated user.
 */
export const statisticsAssetAllocationRetrieveOptions = (options?: Options<StatisticsAssetAllocationRetrieveData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await statisticsAssetAllocationRetrieve({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: statisticsAssetAllocationRetrieveQueryKey(options)
    });
};

export const statisticsCurrentAccountValueRetrieveQueryKey = (options?: Options<StatisticsCurrentAccountValueRetrieveData>) => createQueryKey('statisticsCurrentAccountValueRetrieve', options);

/**
 * Get current account value
 * Get the current account value as well as gain and percent gain for the authenticated user.
 */
export const statisticsCurrentAccountValueRetrieveOptions = (options?: Options<StatisticsCurrentAccountValueRetrieveData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await statisticsCurrentAccountValueRetrieve({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: statisticsCurrentAccountValueRetrieveQueryKey(options)
    });
};

export const statisticsOwnedSharesListQueryKey = (options?: Options<StatisticsOwnedSharesListData>) => createQueryKey('statisticsOwnedSharesList', options);

/**
 * Get owned shares
 * Get owned shares data for the currently authenticated user.
 */
export const statisticsOwnedSharesListOptions = (options?: Options<StatisticsOwnedSharesListData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await statisticsOwnedSharesList({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: statisticsOwnedSharesListQueryKey(options)
    });
};

export const statisticsStatisticsMostTradedListQueryKey = (options?: Options<StatisticsStatisticsMostTradedListData>) => createQueryKey('statisticsStatisticsMostTradedList', options);

/**
 * Get overview about the most traded instruments
 * Returns number of trades, number of buys/sells, avg gain/loss, and total return from the most frequently traded instruments.
 */
export const statisticsStatisticsMostTradedListOptions = (options?: Options<StatisticsStatisticsMostTradedListData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await statisticsStatisticsMostTradedList({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: statisticsStatisticsMostTradedListQueryKey(options)
    });
};

export const statisticsStatisticsTradingOverviewRetrieveQueryKey = (options?: Options<StatisticsStatisticsTradingOverviewRetrieveData>) => createQueryKey('statisticsStatisticsTradingOverviewRetrieve', options);

/**
 * Get trading performance overview
 * Returns total trades, number of buys/sells, average gain/loss, and total return for the current investor.
 */
export const statisticsStatisticsTradingOverviewRetrieveOptions = (options?: Options<StatisticsStatisticsTradingOverviewRetrieveData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await statisticsStatisticsTradingOverviewRetrieve({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: statisticsStatisticsTradingOverviewRetrieveQueryKey(options)
    });
};

export const statisticsStatsRetrieveQueryKey = (options?: Options<StatisticsStatsRetrieveData>) => createQueryKey('statisticsStatsRetrieve', options);

/**
 * Get investor stats
 * Get investor statistics for the currently authenticated user.
 */
export const statisticsStatsRetrieveOptions = (options?: Options<StatisticsStatsRetrieveData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await statisticsStatsRetrieve({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: statisticsStatsRetrieveQueryKey(options)
    });
};

export const statisticsTransactionsHistoryListQueryKey = (options?: Options<StatisticsTransactionsHistoryListData>) => createQueryKey('statisticsTransactionsHistoryList', options);

/**
 * Get transaction history
 * Get transaction history for the currently authenticated user. Can filter by position type (open/closed/both) and ticker symbol.
 */
export const statisticsTransactionsHistoryListOptions = (options?: Options<StatisticsTransactionsHistoryListData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await statisticsTransactionsHistoryList({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: statisticsTransactionsHistoryListQueryKey(options)
    });
};

export const statusRetrieveQueryKey = (options?: Options<StatusRetrieveData>) => createQueryKey('statusRetrieve', options);

/**
 * Get application status
 * Returns a simple status message indicating the application is running.
 */
export const statusRetrieveOptions = (options?: Options<StatusRetrieveData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await statusRetrieve({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: statusRetrieveQueryKey(options)
    });
};

export const testAdminTestRetrieveQueryKey = (options?: Options<TestAdminTestRetrieveData>) => createQueryKey('testAdminTestRetrieve', options);

/**
 * Test admin authentication
 * Test endpoint to verify admin authentication is working.
 */
export const testAdminTestRetrieveOptions = (options?: Options<TestAdminTestRetrieveData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await testAdminTestRetrieve({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: testAdminTestRetrieveQueryKey(options)
    });
};

export const testAllTestRetrieveQueryKey = (options?: Options<TestAllTestRetrieveData>) => createQueryKey('testAllTestRetrieve', options);

/**
 * Test unauthenticated endpoint
 * Test endpoint that doesn't require authentication.
 */
export const testAllTestRetrieveOptions = (options?: Options<TestAllTestRetrieveData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await testAllTestRetrieve({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: testAllTestRetrieveQueryKey(options)
    });
};

export const testAlpacaTestRetrieveQueryKey = (options?: Options<TestAlpacaTestRetrieveData>) => createQueryKey('testAlpacaTestRetrieve', options);

/**
 * Fetch last trade from Alpaca
 * test alpaca.
 */
export const testAlpacaTestRetrieveOptions = (options?: Options<TestAlpacaTestRetrieveData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await testAlpacaTestRetrieve({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: testAlpacaTestRetrieveQueryKey(options)
    });
};

export const testPolygonTestRetrieveQueryKey = (options?: Options<TestPolygonTestRetrieveData>) => createQueryKey('testPolygonTestRetrieve', options);

/**
 * Fetch last trade from Polygon.io
 * test polygon.
 */
export const testPolygonTestRetrieveOptions = (options?: Options<TestPolygonTestRetrieveData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await testPolygonTestRetrieve({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: testPolygonTestRetrieveQueryKey(options)
    });
};

export const testUsersTestRetrieveQueryKey = (options?: Options<TestUsersTestRetrieveData>) => createQueryKey('testUsersTestRetrieve', options);

/**
 * Test user authentication
 * Test endpoint to verify user authentication is working.
 */
export const testUsersTestRetrieveOptions = (options?: Options<TestUsersTestRetrieveData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await testUsersTestRetrieve({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: testUsersTestRetrieveQueryKey(options)
    });
};
